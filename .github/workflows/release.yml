concurrency:
    group: ${{ github.workflow }}

jobs:
    release:
        runs-on: ubuntu-latest
        steps:
            - name: Harden the runner (Audit all outbound calls)
              uses: step-security/harden-runner@0634a2670c59f64b4a01f0f96f84700a4088b9f0 # v2.12.0
              with:
                  egress-policy: audit

            - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
              with:
                  fetch-depth: 0
                  ref: main
                  token: ${{ secrets.GITHUB_TOKEN }}
            - uses: ./.github/actions/prepare

            - run: pnpm build

            - name: Create and publish versions
              id: changesets
              uses: changesets/action@v1
              with:
                  commit: "chore: update versions"
                  title: "chore: update versions"
                  publish: pnpm --filter neondb publish && pnpm --filter vite-plugin-postgres publish
              env:
                  GITHUB_TOKEN: ${{ secrets.TOKEN_GITHUB }}
                  NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
                  NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
            - name: Create GitHub Release Tags
              if: steps.changesets.outputs.published == 'true'
              run: |
                  git config --global user.name 'github-actions'
                  git config --global user.email 'github-actions@github.com'

                  # Get all packages that were published
                  PUBLISHED_PACKAGES=$(cat $HOME/.changesets/published-packages.json | jq -r '.[]')

                      for pkg in $PUBLISHED_PACKAGES; do
                        # Extract name and version from package.json
                        PKG_PATH=$(find . -path "*/package.json" | xargs grep -l "\"name\": \"$pkg\"" | head -n 1)
                        PKG_DIR=$(dirname $PKG_PATH)
                        VERSION=$(jq -r '.version' $PKG_PATH)
                        
                        # Create a tag with package name and version
                        TAG="$pkg@$VERSION"
                        echo "Creating tag: $TAG"
                        
                        # Get the changelog entry
                        CHANGELOG_PATH="$PKG_DIR/CHANGELOG.md"
                        if [ -f "$CHANGELOG_PATH" ]; then
                          # Extract the latest changelog entry (between the latest version header and the next header)
                          # Extract the latest changelog entry (between the latest version header and the next header)
                          # Use awk to extract lines starting from "## $VERSION" until the next version header (## [0-9])
                          # Then, use sed to remove the first and last lines (headers) to isolate the changelog content
                          CHANGELOG_ENTRY=$(awk "/## $VERSION/,/## [0-9]/" "$CHANGELOG_PATH" | sed '1d;$d')
                          
                          # Create tag and release with changelog
                          git tag -a "$TAG" -m "Release $pkg@$VERSION"
                          gh release create "$TAG" --notes "$CHANGELOG_ENTRY" --title "$pkg@$VERSION"
                        else
                          # Create a simple tag if no changelog exists
                          git tag "$TAG"
                          gh release create "$TAG" --notes "Release $pkg@$VERSION" --title "$pkg@$VERSION"
                        fi
                      done
                    env:
                      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

name: Release

on:
    push:
        branches:
            - main

permissions:
    contents: write
    id-token: write
